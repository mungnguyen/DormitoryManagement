{"ast":null,"code":"/**\n * Object#toString() ref for stringify().\n */\nvar toString = Object.prototype.toString;\n/**\n * Cache non-integer test regexp.\n */\n\nvar isint = /^[0-9]+$/;\n\nfunction promote(parent, key) {\n  if (parent[key].length == 0) return parent[key] = {};\n  var t = {};\n\n  for (var i in parent[key]) {\n    t[i] = parent[key][i];\n  }\n\n  parent[key] = t;\n  return t;\n}\n\nfunction parse(parts, parent, key, val) {\n  var part = parts.shift(); // end\n\n  if (!part) {\n    if (Array.isArray(parent[key])) {\n      parent[key].push(val);\n    } else if ('object' == typeof parent[key]) {\n      parent[key] = val;\n    } else if ('undefined' == typeof parent[key]) {\n      parent[key] = val;\n    } else {\n      parent[key] = [parent[key], val];\n    } // array\n\n  } else {\n    var obj = parent[key] = parent[key] || [];\n\n    if (']' == part) {\n      if (Array.isArray(obj)) {\n        if ('' != val) obj.push(val);\n      } else if ('object' == typeof obj) {\n        obj[Object.keys(obj).length] = val;\n      } else {\n        obj = parent[key] = [parent[key], val];\n      } // prop\n\n    } else if (~part.indexOf(']')) {\n      part = part.substr(0, part.length - 1);\n      if (!isint.test(part) && Array.isArray(obj)) obj = promote(parent, key);\n      parse(parts, obj, part, val); // key\n    } else {\n      if (!isint.test(part) && Array.isArray(obj)) obj = promote(parent, key);\n      parse(parts, obj, part, val);\n    }\n  }\n}\n/**\n * Merge parent key/val pair.\n */\n\n\nfunction merge(parent, key, val) {\n  if (~key.indexOf(']')) {\n    var parts = key.split('['),\n        len = parts.length,\n        last = len - 1;\n    parse(parts, parent, 'base', val); // optimize\n  } else {\n    if (!isint.test(key) && Array.isArray(parent.base)) {\n      var t = {};\n\n      for (var k in parent.base) {\n        t[k] = parent.base[k];\n      }\n\n      parent.base = t;\n    }\n\n    set(parent.base, key, val);\n  }\n\n  return parent;\n}\n/**\n * Parse the given obj.\n */\n\n\nfunction parseObject(obj) {\n  var ret = {\n    base: {}\n  };\n  Object.keys(obj).forEach(function (name) {\n    merge(ret, name, obj[name]);\n  });\n  return ret.base;\n}\n/**\n * Parse the given str.\n */\n\n\nfunction parseString(str) {\n  return String(str).split('&').reduce(function (ret, pair) {\n    var eql = pair.indexOf('='),\n        brace = lastBraceInKey(pair),\n        key = pair.substr(0, brace || eql),\n        val = pair.substr(brace || eql, pair.length),\n        val = val.substr(val.indexOf('=') + 1, val.length); // ?foo\n\n    if ('' == key) key = pair, val = '';\n    if ('' == key) return ret;\n    return merge(ret, decode(key), decode(val));\n  }, {\n    base: {}\n  }).base;\n}\n/**\n * Parse the given query `str` or `obj`, returning an object.\n *\n * @param {String} str | {Object} obj\n * @return {Object}\n * @api public\n */\n\n\nexports.parse = function (str) {\n  if (null == str || '' == str) return {};\n  return 'object' == typeof str ? parseObject(str) : parseString(str);\n};\n/**\n * Turn the given `obj` into a query string\n *\n * @param {Object} obj\n * @return {String}\n * @api public\n */\n\n\nvar stringify = exports.stringify = function (obj, prefix) {\n  if (Array.isArray(obj)) {\n    return stringifyArray(obj, prefix);\n  } else if ('[object Object]' == toString.call(obj)) {\n    return stringifyObject(obj, prefix);\n  } else if ('string' == typeof obj) {\n    return stringifyString(obj, prefix);\n  } else {\n    return prefix + '=' + encodeURIComponent(String(obj));\n  }\n};\n/**\n * Stringify the given `str`.\n *\n * @param {String} str\n * @param {String} prefix\n * @return {String}\n * @api private\n */\n\n\nfunction stringifyString(str, prefix) {\n  if (!prefix) throw new TypeError('stringify expects an object');\n  return prefix + '=' + encodeURIComponent(str);\n}\n/**\n * Stringify the given `arr`.\n *\n * @param {Array} arr\n * @param {String} prefix\n * @return {String}\n * @api private\n */\n\n\nfunction stringifyArray(arr, prefix) {\n  var ret = [];\n  if (!prefix) throw new TypeError('stringify expects an object');\n\n  for (var i = 0; i < arr.length; i++) {\n    ret.push(stringify(arr[i], prefix + '[' + i + ']'));\n  }\n\n  return ret.join('&');\n}\n/**\n * Stringify the given `obj`.\n *\n * @param {Object} obj\n * @param {String} prefix\n * @return {String}\n * @api private\n */\n\n\nfunction stringifyObject(obj, prefix) {\n  var ret = [],\n      keys = Object.keys(obj),\n      key;\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    key = keys[i];\n    if ('' == key) continue;\n\n    if (null == obj[key]) {\n      ret.push(encodeURIComponent(key) + '=');\n    } else {\n      ret.push(stringify(obj[key], prefix ? prefix + '[' + encodeURIComponent(key) + ']' : encodeURIComponent(key)));\n    }\n  }\n\n  return ret.join('&');\n}\n/**\n * Set `obj`'s `key` to `val` respecting\n * the weird and wonderful syntax of a qs,\n * where \"foo=bar&foo=baz\" becomes an array.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {String} val\n * @api private\n */\n\n\nfunction set(obj, key, val) {\n  var v = obj[key];\n\n  if (undefined === v) {\n    obj[key] = val;\n  } else if (Array.isArray(v)) {\n    v.push(val);\n  } else {\n    obj[key] = [v, val];\n  }\n}\n/**\n * Locate last brace in `str` within the key.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\n\nfunction lastBraceInKey(str) {\n  var len = str.length,\n      brace,\n      c;\n\n  for (var i = 0; i < len; ++i) {\n    c = str[i];\n    if (']' == c) brace = false;\n    if ('[' == c) brace = true;\n    if ('=' == c && !brace) return i;\n  }\n}\n/**\n * Decode `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\n\nfunction decode(str) {\n  try {\n    return decodeURIComponent(str.replace(/\\+/g, ' '));\n  } catch (err) {\n    return str;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}