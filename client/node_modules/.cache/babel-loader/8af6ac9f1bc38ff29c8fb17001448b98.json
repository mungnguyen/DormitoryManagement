{"ast":null,"code":"// Load modules\nvar Fs = require('fs');\n\nvar Escape = require('./escape'); // Declare internals\n\n\nvar internals = {}; // Clone object or array\n\nexports.clone = function (obj, seen) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  seen = seen || {\n    orig: [],\n    copy: []\n  };\n  var lookup = seen.orig.indexOf(obj);\n\n  if (lookup !== -1) {\n    return seen.copy[lookup];\n  }\n\n  var newObj = obj instanceof Array ? [] : {};\n  seen.orig.push(obj);\n  seen.copy.push(newObj);\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (obj[i] instanceof Date) {\n        newObj[i] = new Date(obj[i].getTime());\n      } else if (obj[i] instanceof RegExp) {\n        var flags = '' + (obj[i].global ? 'g' : '') + (obj[i].ignoreCase ? 'i' : '') + (obj[i].multiline ? 'm' : '');\n        newObj[i] = new RegExp(obj[i].source, flags);\n      } else {\n        newObj[i] = exports.clone(obj[i], seen);\n      }\n    }\n  }\n\n  return newObj;\n}; // Merge all the properties of source into target, source wins in conflic, and by default null and undefined from source are applied\n\n\nexports.merge = function (target, source, isNullOverride\n/* = true */\n, isMergeArrays\n/* = true */\n) {\n  exports.assert(target && typeof target == 'object', 'Invalid target value: must be an object');\n  exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n  if (!source) {\n    return target;\n  }\n\n  if (source instanceof Array) {\n    exports.assert(target instanceof Array, 'Cannot merge array onto an object');\n\n    if (isMergeArrays === false) {\n      // isMergeArrays defaults to true\n      target.length = 0; // Must not change target assignment\n    }\n\n    source.forEach(function (item) {\n      target.push(item);\n    });\n    return target;\n  }\n\n  Object.keys(source).forEach(function (key) {\n    var value = source[key];\n\n    if (value && typeof value === 'object') {\n      if (!target[key] || typeof target[key] !== 'object') {\n        target[key] = exports.clone(value);\n      } else {\n        exports.merge(target[key], source[key], isNullOverride, isMergeArrays);\n      }\n    } else {\n      if (value !== null && value !== undefined) {\n        // Explicit to preserve empty strings\n        target[key] = value;\n      } else if (isNullOverride !== false) {\n        // Defaults to true\n        target[key] = value;\n      }\n    }\n  });\n  return target;\n}; // Apply options to a copy of the defaults\n\n\nexports.applyToDefaults = function (defaults, options) {\n  exports.assert(defaults && typeof defaults == 'object', 'Invalid defaults value: must be an object');\n  exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\n  if (!options) {\n    // If no options, return null\n    return null;\n  }\n\n  var copy = exports.clone(defaults);\n\n  if (options === true) {\n    // If options is set to true, use defaults\n    return copy;\n  }\n\n  return exports.merge(copy, options, false, false);\n}; // Remove duplicate items from array\n\n\nexports.unique = function (array, key) {\n  var index = {};\n  var result = [];\n\n  for (var i = 0, il = array.length; i < il; ++i) {\n    var id = key ? array[i][key] : array[i];\n\n    if (index[id] !== true) {\n      result.push(array[i]);\n      index[id] = true;\n    }\n  }\n\n  return result;\n}; // Convert array into object\n\n\nexports.mapToObject = function (array, key) {\n  if (!array) {\n    return null;\n  }\n\n  var obj = {};\n\n  for (var i = 0, il = array.length; i < il; ++i) {\n    if (key) {\n      if (array[i][key]) {\n        obj[array[i][key]] = true;\n      }\n    } else {\n      obj[array[i]] = true;\n    }\n  }\n\n  return obj;\n}; // Find the common unique items in two arrays\n\n\nexports.intersect = function (array1, array2) {\n  if (!array1 || !array2) {\n    return [];\n  }\n\n  var common = [];\n  var hash = array1 instanceof Array ? exports.mapToObject(array1) : array1;\n  var found = {};\n\n  for (var i = 0, il = array2.length; i < il; ++i) {\n    if (hash[array2[i]] && !found[array2[i]]) {\n      common.push(array2[i]);\n      found[array2[i]] = true;\n    }\n  }\n\n  return common;\n}; // Find which keys are present\n\n\nexports.matchKeys = function (obj, keys) {\n  var matched = [];\n\n  for (var i = 0, il = keys.length; i < il; ++i) {\n    if (obj.hasOwnProperty(keys[i])) {\n      matched.push(keys[i]);\n    }\n  }\n\n  return matched;\n}; // Flatten array\n\n\nexports.flatten = function (array, target) {\n  var result = target || [];\n\n  for (var i = 0, il = array.length; i < il; ++i) {\n    if (Array.isArray(array[i])) {\n      exports.flatten(array[i], result);\n    } else {\n      result.push(array[i]);\n    }\n  }\n\n  return result;\n}; // Remove keys\n\n\nexports.removeKeys = function (object, keys) {\n  for (var i = 0, il = keys.length; i < il; i++) {\n    delete object[keys[i]];\n  }\n}; // Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\n\nexports.reach = function (obj, chain) {\n  var path = chain.split('.');\n  var ref = obj;\n  path.forEach(function (level) {\n    if (ref) {\n      ref = ref[level];\n    }\n  });\n  return ref;\n}; // Inherits a selected set of methods from an object, wrapping functions in asynchronous syntax and catching errors\n\n\nexports.inheritAsync = function (self, obj, keys) {\n  keys = keys || null;\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (keys instanceof Array && keys.indexOf(i) < 0) {\n        continue;\n      }\n\n      self.prototype[i] = function (fn) {\n        return function (callback) {\n          var result = null;\n\n          try {\n            result = fn();\n          } catch (err) {\n            return callback(err);\n          }\n\n          return callback(null, result);\n        };\n      }(obj[i]);\n    }\n  }\n};\n\nexports.formatStack = function (stack) {\n  var trace = [];\n  stack.forEach(function (item) {\n    trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);\n  });\n  return trace;\n};\n\nexports.formatTrace = function (trace) {\n  var display = [];\n  trace.forEach(function (row) {\n    display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');\n  });\n  return display;\n};\n\nexports.callStack = function (slice) {\n  // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n  var v8 = Error.prepareStackTrace;\n\n  Error.prepareStackTrace = function (err, stack) {\n    return stack;\n  };\n\n  var capture = {};\n  Error.captureStackTrace(capture, arguments.callee);\n  var stack = capture.stack;\n  Error.prepareStackTrace = v8;\n  var trace = exports.formatStack(stack);\n\n  if (slice) {\n    return trace.slice(slice);\n  }\n\n  return trace;\n};\n\nexports.displayStack = function (slice) {\n  var trace = exports.callStack(slice === undefined ? 1 : slice + 1);\n  return exports.formatTrace(trace);\n};\n\nexports.abortThrow = false;\n\nexports.abort = function (message, hideStack) {\n  if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {\n    throw new Error(message || 'Unknown error');\n  }\n\n  var stack = '';\n\n  if (!hideStack) {\n    stack = exports.displayStack(1).join('\\n\\t');\n  }\n\n  console.log('ABORT: ' + message + '\\n\\t' + stack);\n  process.exit(1);\n};\n\nexports.assert = function (condition, message) {\n  if (!condition) {\n    throw new Error(message || 'Unknown error');\n  }\n};\n\nexports.loadDirModules = function (path, excludeFiles, target) {\n  // target(filename, name, capName)\n  var exclude = {};\n\n  for (var i = 0, il = excludeFiles.length; i < il; ++i) {\n    exclude[excludeFiles[i] + '.js'] = true;\n  }\n\n  Fs.readdirSync(path).forEach(function (filename) {\n    if (/\\.js$/.test(filename) && !exclude[filename]) {\n      var name = filename.substr(0, filename.lastIndexOf('.'));\n      var capName = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();\n\n      if (typeof target !== 'function') {\n        target[capName] = require(path + '/' + name);\n      } else {\n        target(path + '/' + name, name, capName);\n      }\n    }\n  });\n};\n\nexports.rename = function (obj, from, to) {\n  obj[to] = obj[from];\n  delete obj[from];\n};\n\nexports.Timer = function () {\n  this.reset();\n};\n\nexports.Timer.prototype.reset = function () {\n  this.ts = Date.now();\n};\n\nexports.Timer.prototype.elapsed = function () {\n  return Date.now() - this.ts;\n}; // Load and parse package.json process root or given directory\n\n\nexports.loadPackage = function (dir) {\n  var result = {};\n  var filepath = (dir || process.env.PWD) + '/package.json';\n\n  if (Fs.existsSync(filepath)) {\n    try {\n      result = JSON.parse(Fs.readFileSync(filepath));\n    } catch (e) {}\n  }\n\n  return result;\n}; // Escape string for Regex construction\n\n\nexports.escapeRegex = function (string) {\n  // Escape ^$.*+-?=!:|\\/()[]{},\n  return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n}; // Return an error as first argument of a callback\n\n\nexports.toss = function (condition\n/*, [message], callback */\n) {\n  var message = arguments.length === 3 ? arguments[1] : '';\n  var callback = arguments.length === 3 ? arguments[2] : arguments[1];\n  var err = message instanceof Error ? message : message ? new Error(message) : condition instanceof Error ? condition : new Error();\n\n  if (condition instanceof Error || !condition) {\n    return callback(err);\n  }\n}; // Base64url (RFC 4648) encode\n\n\nexports.base64urlEncode = function (value) {\n  return new Buffer(value, 'binary').toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n}; // Base64url (RFC 4648) decode\n\n\nexports.base64urlDecode = function (encoded) {\n  if (encoded && !encoded.match(/^[\\w\\-]*$/)) {\n    return new Error('Invalid character');\n  }\n\n  try {\n    return new Buffer(encoded.replace(/-/g, '+').replace(/:/g, '/'), 'base64').toString('binary');\n  } catch (err) {\n    return err;\n  }\n}; // Escape attribute value for use in HTTP header\n\n\nexports.escapeHeaderAttribute = function (attribute) {\n  // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n  exports.assert(attribute.match(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/), 'Bad attribute value (' + attribute + ')');\n  return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"'); // Escape quotes and slash\n};\n\nexports.escapeHtml = function (string) {\n  return Escape.escapeHtml(string);\n};\n\nexports.escapeJavaScript = function (string) {\n  return Escape.escapeJavaScript(string);\n};\n/*\r\nvar event = {\r\n    timestamp: now.getTime(),\r\n    tags: ['tag'],\r\n    data: { some: 'data' }\r\n};\r\n*/\n\n\nexports.consoleFunc = console.log;\n\nexports.printEvent = function (event) {\n  var pad = function pad(value) {\n    return (value < 10 ? '0' : '') + value;\n  };\n\n  var now = new Date(event.timestamp);\n  var timestring = (now.getYear() - 100).toString() + pad(now.getMonth() + 1) + pad(now.getDate()) + '/' + pad(now.getHours()) + pad(now.getMinutes()) + pad(now.getSeconds()) + '.' + now.getMilliseconds();\n  var data = event.data;\n\n  if (typeof event.data !== 'string') {\n    try {\n      data = JSON.stringify(event.data);\n    } catch (e) {\n      data = 'JSON Error: ' + e.message;\n    }\n  }\n\n  var output = timestring + ', ' + event.tags[0] + ', ' + data;\n  exports.consoleFunc(output);\n};","map":null,"metadata":{},"sourceType":"script"}