{"ast":null,"code":"// Load modules\nvar Url = require('url');\n\nvar Boom = require('boom');\n\nvar Cryptiles = require('cryptiles');\n\nvar Crypto = require('./crypto');\n\nvar Utils = require('./utils'); // Declare internals\n\n\nvar internals = {}; // Hawk authentication\n\n/*\n * Arguments and options are the same as index.js with the exception that the only supported options are:\n * 'hostHeaderName', 'localtimeOffsetMsec'\n */\n\nexports.authenticate = function (req, credentialsFunc, options, callback) {\n  // Application time\n  var now = Utils.now() + (options.localtimeOffsetMsec || 0); // Convert node Http request object to a request configuration object\n\n  var request = Utils.parseRequest(req, options);\n\n  if (request instanceof Error) {\n    return callback(Boom.badRequest(request.message));\n  } // Extract bewit\n  //                                 1     2             3           4     \n\n\n  var resource = request.url.match(/^(\\/.*)([\\?&])bewit\\=([^&$]*)(?:&(.+))?$/);\n\n  if (!resource) {\n    return callback(Boom.unauthorized(null, 'Hawk'));\n  } // Bewit not empty\n\n\n  if (!resource[3]) {\n    return callback(Boom.unauthorized('Empty bewit', 'Hawk'));\n  } // Verify method is GET\n\n\n  if (request.method !== 'GET' && request.method !== 'HEAD') {\n    return callback(Boom.unauthorized('Invalid method', 'Hawk'));\n  } // No other authentication\n\n\n  if (request.authorization) {\n    return callback(Boom.badRequest('Multiple authentications', 'Hawk'));\n  } // Parse bewit\n\n\n  var bewitString = Utils.base64urlDecode(resource[3]);\n\n  if (bewitString instanceof Error) {\n    return callback(Boom.badRequest('Invalid bewit encoding'));\n  } // Bewit format: id\\exp\\mac\\ext ('\\' is used because it is a reserved header attribute character)\n\n\n  var bewitParts = bewitString.split('\\\\');\n\n  if (!bewitParts || bewitParts.length !== 4) {\n    return callback(Boom.badRequest('Invalid bewit structure'));\n  }\n\n  var bewit = {\n    id: bewitParts[0],\n    exp: parseInt(bewitParts[1], 10),\n    mac: bewitParts[2],\n    ext: bewitParts[3] || ''\n  };\n\n  if (!bewit.id || !bewit.exp || !bewit.mac) {\n    return callback(Boom.badRequest('Missing bewit attributes'));\n  } // Construct URL without bewit\n\n\n  var url = resource[1];\n\n  if (resource[4]) {\n    url += resource[2] + resource[4];\n  } // Check expiration\n\n\n  if (bewit.exp * 1000 <= now) {\n    return callback(Boom.unauthorized('Access expired', 'Hawk'), null, bewit);\n  } // Fetch Hawk credentials\n\n\n  credentialsFunc(bewit.id, function (err, credentials) {\n    if (err) {\n      return callback(err, credentials || null, bewit.ext);\n    }\n\n    if (!credentials) {\n      return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, bewit);\n    }\n\n    if (!credentials.key || !credentials.algorithm) {\n      return callback(Boom.internal('Invalid credentials'), credentials, bewit);\n    }\n\n    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {\n      return callback(Boom.internal('Unknown algorithm'), credentials, bewit);\n    } // Calculate MAC\n\n\n    var mac = Crypto.calculateMac('bewit', {\n      credentials: credentials,\n      ts: bewit.exp,\n      nonce: '',\n      method: 'GET',\n      resource: url,\n      host: request.host,\n      port: request.port,\n      ext: bewit.ext\n    });\n\n    if (!Cryptiles.fixedTimeComparison(mac, bewit.mac)) {\n      return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, bewit);\n    } // Successful authentication\n\n\n    return callback(null, credentials, bewit);\n  });\n}; // Generate a bewit value for a given URI\n\n/*\n * credentials is an object with the following keys: 'id, 'key', 'algorithm'.\n * options is an object with the following optional keys: 'ext', 'localtimeOffsetMsec'\n */\n\n/*\n    uri: 'http://example.com/resource?a=b' or object from Url.parse()\n    options: {\n\n        // Required\n\n        credentials: {\n            id: 'dh37fgj492je',\n            key: 'aoijedoaijsdlaksjdl',\n            algorithm: 'sha256'                             // 'sha1', 'sha256'\n        },\n        ttlSec: 60 * 60,                                    // TTL in seconds\n\n        // Optional\n\n        ext: 'application-specific',                        // Application specific data sent via the ext attribute\n        localtimeOffsetMsec: 400                            // Time offset to sync with server time\n    };\n*/\n\n\nexports.getBewit = function (uri, options) {\n  // Validate inputs\n  if (!uri || typeof uri !== 'string' && typeof uri !== 'object' || !options || typeof options !== 'object' || !options.ttlSec) {\n    return '';\n  }\n\n  options.ext = options.ext === null || options.ext === undefined ? '' : options.ext; // Zero is valid value\n  // Application time\n\n  var now = Utils.now() + (options.localtimeOffsetMsec || 0); // Validate credentials\n\n  var credentials = options.credentials;\n\n  if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {\n    return '';\n  }\n\n  if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {\n    return '';\n  } // Parse URI\n\n\n  if (typeof uri === 'string') {\n    uri = Url.parse(uri);\n  } // Calculate signature\n\n\n  var exp = Math.floor(now / 1000) + options.ttlSec;\n  var mac = Crypto.calculateMac('bewit', {\n    credentials: credentials,\n    ts: exp,\n    nonce: '',\n    method: 'GET',\n    resource: uri.pathname + (uri.search || ''),\n    // Maintain trailing '?'\n    host: uri.hostname,\n    port: uri.port || (uri.protocol === 'http:' ? 80 : 443),\n    ext: options.ext\n  }); // Construct bewit: id\\exp\\mac\\ext\n\n  var bewit = credentials.id + '\\\\' + exp + '\\\\' + mac + '\\\\' + options.ext;\n  return Utils.base64urlEncode(bewit);\n};","map":null,"metadata":{},"sourceType":"script"}