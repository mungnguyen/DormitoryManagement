{"ast":null,"code":"// Load modules\nvar Dgram = require('dgram');\n\nvar Dns = require('dns');\n\nvar Hoek = require('hoek'); // Declare internals\n\n\nvar internals = {};\n\nexports.time = function (options, callback) {\n  if (arguments.length !== 2) {\n    callback = arguments[0];\n    options = {};\n  }\n\n  var settings = Hoek.clone(options);\n  settings.host = settings.host || 'pool.ntp.org';\n  settings.port = settings.port || 123;\n  settings.resolveReference = settings.resolveReference || false; // Declare variables used by callback\n\n  var timeoutId = 0;\n  var sent = 0; // Ensure callback is only called once\n\n  var isFinished = false;\n\n  var finish = function finish(err, result) {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = 0;\n    }\n\n    if (!isFinished) {\n      isFinished = true;\n      socket.close();\n      return callback(err, result);\n    }\n  }; // Create UDP socket\n\n\n  var socket = Dgram.createSocket('udp4');\n  socket.on('error', function (err) {\n    return finish(err);\n  }); // Listen to incoming messages\n\n  socket.on('message', function (buffer, rinfo) {\n    var received = Date.now();\n    var message = new internals.NtpMessage(buffer);\n\n    if (!message.isValid) {\n      return finish(new Error('Invalid server response'), message);\n    }\n\n    if (message.originateTimestamp !== sent) {\n      return finish(new Error('Wrong originate timestamp'), message);\n    } // Timestamp Name          ID   When Generated\n    // ------------------------------------------------------------\n    // Originate Timestamp     T1   time request sent by client\n    // Receive Timestamp       T2   time request received by server\n    // Transmit Timestamp      T3   time reply sent by server\n    // Destination Timestamp   T4   time reply received by client\n    //\n    // The roundtrip delay d and system clock offset t are defined as:\n    //\n    // d = (T4 - T1) - (T3 - T2)     t = ((T2 - T1) + (T3 - T4)) / 2\n\n\n    var T1 = message.originateTimestamp;\n    var T2 = message.receiveTimestamp;\n    var T3 = message.transmitTimestamp;\n    var T4 = received;\n    message.d = T4 - T1 - (T3 - T2);\n    message.t = (T2 - T1 + (T3 - T4)) / 2;\n    message.receivedLocally = received;\n\n    if (!settings.resolveReference || message.stratum !== 'secondary') {\n      return finish(null, message);\n    } // Resolve reference IP address\n\n\n    Dns.reverse(message.referenceId, function (err, domains) {\n      if (!err) {\n        message.referenceHost = domains[0];\n      }\n\n      return finish(null, message);\n    });\n  }); // Set timeout\n\n  if (settings.timeout) {\n    timeoutId = setTimeout(function () {\n      timeoutId = 0;\n      return finish(new Error('Timeout'));\n    }, settings.timeout);\n  } // Construct NTP message\n\n\n  var message = new Buffer(48);\n\n  for (var i = 0; i < 48; i++) {\n    // Zero message\n    message[i] = 0;\n  }\n\n  message[0] = (0 << 6) + (4 << 3) + (3 << 0); // Set version number to 4 and Mode to 3 (client)\n\n  sent = Date.now();\n  internals.fromMsecs(sent, message, 40); // Set transmit timestamp (returns as originate)\n  // Send NTP request\n\n  socket.send(message, 0, message.length, settings.port, settings.host, function (err, bytes) {\n    if (err || bytes !== 48) {\n      return finish(err || new Error('Could not send entire message'));\n    }\n  });\n};\n\ninternals.NtpMessage = function (buffer) {\n  this.isValid = false; // Validate\n\n  if (buffer.length !== 48) {\n    return;\n  } // Leap indicator\n\n\n  var li = buffer[0] >> 6;\n\n  switch (li) {\n    case 0:\n      this.leapIndicator = 'no-warning';\n      break;\n\n    case 1:\n      this.leapIndicator = 'last-minute-61';\n      break;\n\n    case 2:\n      this.leapIndicator = 'last-minute-59';\n      break;\n\n    case 3:\n      this.leapIndicator = 'alarm';\n      break;\n  } // Version\n\n\n  var vn = (buffer[0] & 0x38) >> 3;\n  this.version = vn; // Mode\n\n  var mode = buffer[0] & 0x7;\n\n  switch (mode) {\n    case 1:\n      this.mode = 'symmetric-active';\n      break;\n\n    case 2:\n      this.mode = 'symmetric-passive';\n      break;\n\n    case 3:\n      this.mode = 'client';\n      break;\n\n    case 4:\n      this.mode = 'server';\n      break;\n\n    case 5:\n      this.mode = 'broadcast';\n      break;\n\n    case 0:\n    case 6:\n    case 7:\n      this.mode = 'reserved';\n      break;\n  } // Stratum\n\n\n  var stratum = buffer[1];\n\n  if (stratum === 0) {\n    this.stratum = 'death';\n  } else if (stratum === 1) {\n    this.stratum = 'primary';\n  } else if (stratum <= 15) {\n    this.stratum = 'secondary';\n  } else {\n    this.stratum = 'reserved';\n  } // Poll interval (msec)\n\n\n  this.pollInterval = Math.round(Math.pow(2, buffer[2])) * 1000; // Precision (msecs)\n\n  this.precision = Math.pow(2, buffer[3]) * 1000; // Root delay (msecs)\n\n  var rootDelay = 256 * (256 * (256 * buffer[4] + buffer[5]) + buffer[6]) + buffer[7];\n  this.rootDelay = 1000 * (rootDelay / 0x10000); // Root dispersion (msecs)\n\n  this.rootDispersion = ((buffer[8] << 8) + buffer[9] + ((buffer[10] << 8) + buffer[11]) / Math.pow(2, 16)) * 1000; // Reference identifier\n\n  this.referenceId = '';\n\n  switch (this.stratum) {\n    case 'death':\n    case 'primary':\n      this.referenceId = String.fromCharCode(buffer[12]) + String.fromCharCode(buffer[13]) + String.fromCharCode(buffer[14]) + String.fromCharCode(buffer[15]);\n      break;\n\n    case 'secondary':\n      this.referenceId = '' + buffer[12] + '.' + buffer[13] + '.' + buffer[14] + '.' + buffer[15];\n      break;\n  } // Reference timestamp\n\n\n  this.referenceTimestamp = internals.toMsecs(buffer, 16); // Originate timestamp\n\n  this.originateTimestamp = internals.toMsecs(buffer, 24); // Receive timestamp\n\n  this.receiveTimestamp = internals.toMsecs(buffer, 32); // Transmit timestamp\n\n  this.transmitTimestamp = internals.toMsecs(buffer, 40); // Validate\n\n  if (this.version === 4 && this.stratum !== 'reserved' && this.mode === 'server' && this.originateTimestamp && this.receiveTimestamp && this.transmitTimestamp) {\n    this.isValid = true;\n  }\n\n  return this;\n};\n\ninternals.toMsecs = function (buffer, offset) {\n  var seconds = 0;\n  var fraction = 0;\n\n  for (var i = 0; i < 4; ++i) {\n    seconds = seconds * 256 + buffer[offset + i];\n  }\n\n  for (i = 4; i < 8; ++i) {\n    fraction = fraction * 256 + buffer[offset + i];\n  }\n\n  return (seconds - 2208988800 + fraction / Math.pow(2, 32)) * 1000;\n};\n\ninternals.fromMsecs = function (ts, buffer, offset) {\n  var seconds = Math.floor(ts / 1000) + 2208988800;\n  var fraction = Math.round(ts % 1000 / 1000 * Math.pow(2, 32));\n  buffer[offset + 0] = (seconds & 0xFF000000) >> 24;\n  buffer[offset + 1] = (seconds & 0x00FF0000) >> 16;\n  buffer[offset + 2] = (seconds & 0x0000FF00) >> 8;\n  buffer[offset + 3] = seconds & 0x000000FF;\n  buffer[offset + 4] = (fraction & 0xFF000000) >> 24;\n  buffer[offset + 5] = (fraction & 0x00FF0000) >> 16;\n  buffer[offset + 6] = (fraction & 0x0000FF00) >> 8;\n  buffer[offset + 7] = fraction & 0x000000FF;\n}; // Offset singleton\n\n\ninternals.last = {\n  offset: 0,\n  expires: 0,\n  host: '',\n  port: 0\n};\n\nexports.offset = function (options, callback) {\n  if (arguments.length !== 2) {\n    callback = arguments[0];\n    options = {};\n  }\n\n  var now = Date.now();\n  var clockSyncRefresh = options.clockSyncRefresh || 24 * 60 * 60 * 1000; // Daily\n\n  if (internals.last.offset && internals.last.host === options.host && internals.last.port === options.port && now < internals.last.expires) {\n    return callback(null, internals.last.offset);\n  }\n\n  exports.time(options, function (err, time) {\n    if (err) {\n      return callback(err, 0);\n    }\n\n    internals.last = {\n      offset: Math.round(time.t),\n      expires: now + clockSyncRefresh,\n      host: options.host,\n      port: options.port\n    };\n    return callback(null, internals.last.offset);\n  });\n}; // Now singleton\n\n\ninternals.now = {\n  intervalId: 0\n};\n\nexports.start = function (options, callback) {\n  if (arguments.length !== 2) {\n    callback = arguments[0];\n    options = {};\n  }\n\n  if (internals.now.intervalId) {\n    return callback();\n  }\n\n  exports.offset(options, function (err, offset) {\n    internals.now.intervalId = setInterval(function () {\n      exports.offset(options, function () {});\n    }, options.clockSyncRefresh || 24 * 60 * 60 * 1000); // Daily\n\n    return callback();\n  });\n};\n\nexports.stop = function () {\n  if (!internals.now.intervalId) {\n    return;\n  }\n\n  clearInterval(internals.now.intervalId);\n  internals.now.intervalId = 0;\n};\n\nexports.isLive = function () {\n  return !!internals.now.intervalId;\n};\n\nexports.now = function () {\n  var now = Date.now();\n\n  if (!exports.isLive() || now >= internals.last.expires) {\n    return now;\n  }\n\n  return now + internals.last.offset;\n};","map":null,"metadata":{},"sourceType":"script"}