{"ast":null,"code":"var CombinedStream = require('combined-stream');\n\nvar util = require('util');\n\nvar path = require('path');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar parseUrl = require('url').parse;\n\nvar fs = require('fs');\n\nvar mime = require('mime');\n\nvar async = require('async');\n\nmodule.exports = FormData;\n\nfunction FormData() {\n  this._overheadLength = 0;\n  this._valueLength = 0;\n  this._lengthRetrievers = [];\n  CombinedStream.call(this);\n}\n\nutil.inherits(FormData, CombinedStream);\nFormData.LINE_BREAK = '\\r\\n';\n\nFormData.prototype.append = function (field, value, options) {\n  options = options || {};\n  var append = CombinedStream.prototype.append.bind(this); // all that streamy business can't handle numbers\n\n  if (typeof value == 'number') value = '' + value;\n\n  var header = this._multiPartHeader(field, value, options);\n\n  var footer = this._multiPartFooter(field, value, options);\n\n  append(header);\n  append(value);\n  append(footer); // pass along options.knownLength\n\n  this._trackLength(header, value, options);\n};\n\nFormData.prototype._trackLength = function (header, value, options) {\n  var valueLength = 0; // used w/ trackLengthSync(), when length is known.\n  // e.g. for streaming directly from a remote server,\n  // w/ a known file a size, and not wanting to wait for\n  // incoming file to finish to get its size.\n\n  if (options.knownLength != null) {\n    valueLength += +options.knownLength;\n  } else if (Buffer.isBuffer(value)) {\n    valueLength = value.length;\n  } else if (typeof value === 'string') {\n    valueLength = Buffer.byteLength(value);\n  }\n\n  this._valueLength += valueLength; // @check why add CRLF? does this account for custom/multiple CRLFs?\n\n  this._overheadLength += Buffer.byteLength(header) + +FormData.LINE_BREAK.length; // empty or either doesn't have path or not an http response\n\n  if (!value || !value.path && !(value.readable && value.hasOwnProperty('httpVersion'))) {\n    return;\n  }\n\n  this._lengthRetrievers.push(function (next) {\n    // do we already know the size?\n    // 0 additional leaves value from getSyncLength()\n    if (options.knownLength != null) {\n      next(null, 0); // check if it's local file\n    } else if (value.hasOwnProperty('fd')) {\n      fs.stat(value.path, function (err, stat) {\n        if (err) {\n          next(err);\n          return;\n        }\n\n        next(null, stat.size);\n      }); // or http response\n    } else if (value.hasOwnProperty('httpVersion')) {\n      next(null, +value.headers['content-length']); // or request stream http://github.com/mikeal/request\n    } else if (value.hasOwnProperty('httpModule')) {\n      // wait till response come back\n      value.on('response', function (response) {\n        value.pause();\n        next(null, +response.headers['content-length']);\n      });\n      value.resume(); // something else\n    } else {\n      next('Unknown stream');\n    }\n  });\n};\n\nFormData.prototype._multiPartHeader = function (field, value, options) {\n  var boundary = this.getBoundary();\n  var header = ''; // custom header specified (as string)?\n  // it becomes responsible for boundary\n  // (e.g. to handle extra CRLFs on .NET servers)\n\n  if (options.header != null) {\n    header = options.header;\n  } else {\n    header += '--' + boundary + FormData.LINE_BREAK + 'Content-Disposition: form-data; name=\"' + field + '\"'; // fs- and request- streams have path property\n    // or use custom filename and/or contentType\n    // TODO: Use request's response mime-type\n\n    if (options.filename || value.path) {\n      header += '; filename=\"' + path.basename(options.filename || value.path) + '\"' + FormData.LINE_BREAK + 'Content-Type: ' + (options.contentType || mime.lookup(options.filename || value.path)); // http response has not\n    } else if (value.readable && value.hasOwnProperty('httpVersion')) {\n      header += '; filename=\"' + path.basename(value.client._httpMessage.path) + '\"' + FormData.LINE_BREAK + 'Content-Type: ' + value.headers['content-type'];\n    }\n\n    header += FormData.LINE_BREAK + FormData.LINE_BREAK;\n  }\n\n  return header;\n};\n\nFormData.prototype._multiPartFooter = function (field, value, options) {\n  return function (next) {\n    var footer = FormData.LINE_BREAK;\n    var lastPart = this._streams.length === 0;\n\n    if (lastPart) {\n      footer += this._lastBoundary();\n    }\n\n    next(footer);\n  }.bind(this);\n};\n\nFormData.prototype._lastBoundary = function () {\n  return '--' + this.getBoundary() + '--';\n};\n\nFormData.prototype.getHeaders = function (userHeaders) {\n  var formHeaders = {\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\n  };\n\n  for (var header in userHeaders) {\n    formHeaders[header.toLowerCase()] = userHeaders[header];\n  }\n\n  return formHeaders;\n};\n\nFormData.prototype.getCustomHeaders = function (contentType) {\n  contentType = contentType ? contentType : 'multipart/form-data';\n  var formHeaders = {\n    'content-type': contentType + '; boundary=' + this.getBoundary(),\n    'content-length': this.getLengthSync()\n  };\n  return formHeaders;\n};\n\nFormData.prototype.getBoundary = function () {\n  if (!this._boundary) {\n    this._generateBoundary();\n  }\n\n  return this._boundary;\n};\n\nFormData.prototype._generateBoundary = function () {\n  // This generates a 50 character boundary similar to those used by Firefox.\n  // They are optimized for boyer-moore parsing.\n  var boundary = '--------------------------';\n\n  for (var i = 0; i < 24; i++) {\n    boundary += Math.floor(Math.random() * 10).toString(16);\n  }\n\n  this._boundary = boundary;\n};\n\nFormData.prototype.getLengthSync = function () {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  return knownLength;\n};\n\nFormData.prototype.getLength = function (cb) {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  if (!this._lengthRetrievers.length) {\n    process.nextTick(cb.bind(this, null, knownLength));\n    return;\n  }\n\n  async.parallel(this._lengthRetrievers, function (err, values) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    values.forEach(function (length) {\n      knownLength += length;\n    });\n    cb(null, knownLength);\n  });\n};\n\nFormData.prototype.submit = function (params, cb) {\n  this.getLength(function (err, length) {\n    var request,\n        options,\n        defaults = {\n      method: 'post',\n      port: 80,\n      headers: this.getHeaders({\n        'Content-Length': length\n      })\n    }; // parse provided url if it's string\n    // or treat it as options object\n\n    if (typeof params == 'string') {\n      params = parseUrl(params);\n      options = populate({\n        port: params.port,\n        path: params.pathname,\n        host: params.hostname\n      }, defaults);\n    } else // use custom params\n      {\n        options = populate(params, defaults);\n      } // https if specified, fallback to http in any other case\n\n\n    if (params.protocol == 'https:') {\n      // override default port\n      if (!params.port) options.port = 443;\n      request = https.request(options);\n    } else {\n      request = http.request(options);\n    }\n\n    this.pipe(request);\n\n    if (cb) {\n      request.on('error', cb);\n      request.on('response', cb.bind(this, null));\n    }\n\n    return request;\n  }.bind(this));\n};\n/*\n * Santa's little helpers\n */\n// populates missing values\n\n\nfunction populate(dst, src) {\n  for (var prop in src) {\n    if (!dst[prop]) dst[prop] = src[prop];\n  }\n\n  return dst;\n}","map":null,"metadata":{},"sourceType":"script"}